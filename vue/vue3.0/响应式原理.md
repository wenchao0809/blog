# `Vue3.0`响应式原理

## 定义

### ref

用于将原始类型，转换为响应式的类型

#### 用法

~~~js

import { ref } from 'vue'
const refInt = ref(0)

refInt.value++ // 响应式的会追踪依赖， 可以在模板中、computed、 和watch中监听变化

~~~


#### 模板中自动`unRef`

为了减轻使用`ref`的心智复旦模板中的`ref`和响应式对象中的`ref`会自动`unRef` 如下

~~~js
import { ref, reactive } from 'vue'
const refInt = ref(0)

const template = `<div>{{ refInt }}</div>`  // 自动 unRef 不用显示写 refInt.value

const reactiveObj = reactive({ test: refInt })

console.log(reactiveObj.test) // 自动 unRef 不用显示写 reactiveObj.test.value
~~~

`unRef`的实现如下

~~~js
function unRef (val) {
  return isRef(val) ? val.value : val
} 
~~~

#### ref 的实现

~~~js

export function ref(value?: unknown) {
  return createRef(value)
}


class RefImpl<T> {
  private _value: T

  public readonly __v_isRef = true

  constructor(private _rawValue: T, public readonly _shallow = false) {
    this._value = _shallow ? _rawValue : convert(_rawValue)
  }

  get value() {
    track(toRaw(this), TrackOpTypes.GET, 'value')
    return this._value
  }

  set value(newVal) {
    if (hasChanged(toRaw(newVal), this._rawValue)) {
      this._rawValue = newVal
      this._value = this._shallow ? newVal : convert(newVal)
      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)
    }
  }
}

function createRef(rawValue: unknown, shallow = false) {
  if (isRef(rawValue)) {
    return rawValue
  }
  return new RefImpl(rawValue, shallow)
}
~~~

其实就是把原始类型转换为 `get`和`set`属性， 类似 `Vue2`的响应式属性。

#### 浅的和深的

默认是“深的“如果传入`ref`的是一个对象则会调用`reactive`将对象转换为响应式对象。

`shallowRef`可以创建一个之跟踪自己`.value`的更改，不会跟踪嵌套属性。

~~~js

function shallowRef(value?: unknown) {
  return createRef(value, true)
}

~~~

结合上面`ref`的实现，这里的第二个参数为`true`就是生命创建浅的`ref`

#### `toRef`和`toRefs`

`toRef`基于响应式对象的一个属性创建一个`ref`并和原属性之前保持关联。 如下

~~~js

const ro = reactive({ x: 1 })

const refInt = toRef(ro, 'x')

refInt.value = 0

console.log(ro.x) // 0
// 多用于响应式对象解构保持响应性
~~~

`toRefs` 将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的ref

~~~js
const ro = reactive({ x: 1, y: 1 })

const roRef = toRefs(ro)

roRef.x.value = 2
roRef.y.value = 3
console.log(ro.x) // 2
console.log(ro.y) // 3
~~~

实现

~~~js
export function toRefs<T extends object>(object: T): ToRefs<T> {
  if (__DEV__ && !isProxy(object)) {
    console.warn(`toRefs() expects a reactive object but received a plain one.`)
  }
  const ret: any = isArray(object) ? new Array(object.length) : {}
  for (const key in object) {
    ret[key] = toRef(object, key)
  }
  return ret
}

class ObjectRefImpl<T extends object, K extends keyof T> {
  public readonly __v_isRef = true

  constructor(private readonly _object: T, private readonly _key: K) {}

  get value() {
    return this._object[this._key]
  }

  set value(newVal) {
    this._object[this._key] = newVal
  }
}

export function toRef<T extends object, K extends keyof T>(
  object: T,
  key: K
): ToRef<T[K]> {
  return isRef(object[key])
    ? object[key]
    : (new ObjectRefImpl(object, key) as any)
}
~~~

只是利用`get`和`set`做了一下代理

#### 自定义`ref`

`customRef` 允许你创建一个自定义的`ref`, 这个函数接收一个函数， 此函数会接收 `track`和`trigger`这两个函数允许你自定义依赖跟踪和消息发布的时机。

~~~js
function useDebouncedRef(value, delay = 200) {
  let timeout
  return customRef((track, trigger) => {
    return {
      get() {
        track()
        return value
      },
      set(newValue) {
        clearTimeout(timeout)
        timeout = setTimeout(() => {
          value = newValue
          trigger()
        }, delay)
      }
    }
  })
}
~~~

官方防抖的例子， `get`中 `track`要记得调用,不然调用`trigger`就没什么作用了。
实现


~~~js
export function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {
  return new CustomRefImpl(factory) as any
}

class CustomRefImpl<T> {
  private readonly _get: ReturnType<CustomRefFactory<T>>['get']
  private readonly _set: ReturnType<CustomRefFactory<T>>['set']

  public readonly __v_isRef = true

  constructor(factory: CustomRefFactory<T>) {
    const { get, set } = factory(
      () => track(this, TrackOpTypes.GET, 'value'),
      () => trigger(this, TriggerOpTypes.SET, 'value')
    )
    this._get = get
    this._set = set
  }

  get value() {
    return this._get()
  }

  set value(newVal) {
    this._set(newVal)
  }
}
~~~
### `Reactive Object`

#### TargetType 目标类型

能被`reactive`转换为响应式对象的类型

> 1. COMMON 类型 包括 `Array`和`Object`。
> 2. COLLECTION 类型包括 `Map` 、`Set` 、`WeakMap` 、`WeakSet`。
> 3. INVALID 类型 如果不是以上类型，则不能，原始类型使用`Ref`

#### 数组和对象

~~~js
export function reactive(target: object) {
  // if trying to observe a readonly proxy, return the readonly version.
  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {
    return target
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers
  )
}
~~~

####  


### `effect`

### `deps`



只读属性， 不会被追踪依赖，因为只读的是不能更改的所以不需要在依赖变化时执行操作