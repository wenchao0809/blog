### 基础知识

#### 增长数量级的分类

假设输入为`N`那么有

#####  常数级别
运行时间为常数,不依赖`N`
##### 对数级别
运行时间增长数量级为`logN`的程序仅次于常熟级别的算法，这里通常不会指定底数因为底数和增长的数量级无关。
##### 线性级别
运行时间和输入`N`成正比。

##### 线性对数区别
`NlogN`
##### 平方级别
`N^2`
##### 立方级别
`N^3`
##### 指数级别
形如`2^N`这种

### 二叉树

#### 完全二叉树
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

#### 满二叉树
一棵深度为k且有个结点的二叉树称为满二叉树，大意是如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

![](./images/BRTree/tree.jpg)

#### 二叉查找树（Binary Sort Tree

##### 最好的情况

当插入顺序刚好是完美平衡时最优, 此时时间复杂度`lgN`

![](./images/BRTree/BSTbest.jpg)

##### 一般情况, 平均时间复杂度`1.39lgN`

![](./images/BRTree/BSTgeneral.jpg)

##### 最坏的情况,时间复杂度`N`

![](./images/BRTree/BSTworst.jpg)

#### 平衡二叉树 (Balance Tree，BT) 
 任意节点的子树的高度差都小于等于1。
 
### 2-3树

> 插入和删除节点后保持完美平衡

对于普通的二叉树都是由`2-`节点成(含有一个键和两条链接),而现在我们引入`3-`节点，(含有两个键和三条链接)，如下图

![](./images/BRTree/2-3Tree.jpg)

在`2-3`树中查找和在`二叉树`中查找的算法基本一致，要判断一个键是否在树中，我们先将它和根节点比较，如果相等则命中，否则我们就根据比较结果找到指向相应区间的链接。

#### 向`2-`节点插入新键

如果像二叉树一样我们先进行一次未命中的查找，然后把节点插入底部，这样树就不能保持我没平衡了，所以我们引入`3-`节点
现在 
#### 向一棵只含有一个`3-节点`的树中插入键


