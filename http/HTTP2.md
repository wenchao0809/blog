
## 强制HTPPS


### 多路复用

### HTTP管道化的限制

1. 管道化要求服务端按照请求发送的顺序返回响应（FIFO），原因很简单，HTTP请求和响应并没有序号标识，无法将乱序的响应与请求关联起来。
2. 客户端需要保持未收到响应的请求，当连接意外中断时，需要重新发送这部分请求。只有幂等的请求才能进行管道化，也就是只有GET和HEAD请求才能管道化，否则可能会出现意料之外的结果

### HTTP管道化引起的请求队头阻塞

前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。

### 非管道化

非管道化，完全串行执行，请求->响应->请求->响应...，后一个请求必须在前一个响应之后发送。

解决http队头阻塞的方法：

1. 并发TCP连接（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）
2. 域名分片（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）

[什么是队头阻塞](https://juejin.cn/post/6844903853985366023)

多路复用直白的说就是所有的请求都是通过一个 `TCP` 连接并发完成。 该连接可以承载任意数量的双向数据流。 `HTTP/1.x` 虽然通过 `pipeline` 也能并发请求，



## 二进制分帧

HTTP/2 采用二进制格式传输数据，而非 `HTTP/1.x` 的文本格式。 `HTTP/2` 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。


## 头部压缩

首部压缩移除了请求中的一些啰嗦首部，你可以通过很少的 IP package，承载数十个乃至上百个的请求，更符合最小数据量的理想化原则。

## 服务端推送 

服务端能够更快的把资源推送给客户端。例如服务端可以主动把 `JS` 和 `CSS` 文件推送给客户端，而不需要客户端解析 `HTML` 再发送这些请求。当客户端需要的时候，它已经在客户端了。