服务器开启压缩是一种提升性能的手段， 消息体压缩是在服务器端完成的，并且在传输过程中保持不变，直到抵达客户端。不管途中遇到什么样的中间节点，它们都会使消息体保持原样。

所有的现代浏览器及服务器都支持该技术，唯一需要协商的是所采用的压缩算法。这些压缩算法是为文本内容进行过优化的。在20世纪，压缩技术快速发展，为数众多的算法相继出现，扩大了可选的范围。如今只有两种算法有着举足轻重的地位：gzip 应用最广泛，br 则是新的挑战者。

为了选择要采用的压缩算法，浏览器和服务器之间会使用主动协商机制。浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级，服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应中， Vary 首部中至少要包含 Accept-Encoding ；这样的话，缓存服务器就可以对资源的不同展现形式进行缓存。

**请求头**

~~~js
Accept-Encoding: gzip, br
~~~

**响应头**

~~~js
Content-Encoding: gzip
vary: Accept-Encoding
~~~

但是并不是对所有的资源都需要开启压缩， 对于图、音频、视频这些已经压缩过文件，如果也开启压缩只会浪费服务器性能， 一般像`nginx`如果开启了`gzip: on`已经自动了添加这些规则， 只会对一些值得压缩的文件类型开启压缩。

node包`compressible`可以获取一个类型可否被压缩用法如下, 

~~~js
compressible('application/pdf') // true or false
~~~

`compressible`是基于`mide-db`针对每种类型定义如下

~~~js
  "application/pdf": {
    "source": "iana",
    "compressible": false,
    "extensions": ["pdf"]
  },
~~~

一般不需要手动配置这些规则， `nginx`和`koa-compress`都会自动处理如果要做一些定制化的配置则需要了解下。
